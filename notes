#!/usr/bin/env bash

QUICKNOTE_FORMAT="quicknote-%Y-%m-%d"
PREFERED_EXT=.md
GREP_COLOR=always

# Look for configuration file at ~/.config/notes/config and use it
if [ -f ~/.config/notes/config ]; then
    . ~/.config/notes/config
fi

file_ext=$PREFERED_EXT
configured_dir=${NOTES_DIRECTORY%/} # Remove trailing slashes
notes_dir="${configured_dir:-$HOME/notes}"
escaped_notes_dir="$(printf "$notes_dir" | sed -e 's/[]\/$*.^|[]/\\&/g')"

# If no $EDITOR, look for `editor` (symlink on debian/ubuntu/etc)
if [ -z "$EDITOR" ] && type editor &>/dev/null; then
    EDITOR=editor
fi

without_notes_dir() {
    cat | sed -e "s/$escaped_notes_dir//g" | sed -E "s/^\/+//g"
}

ls_notes() {
    local ls_output=$(ls -p "$notes_dir/$*" 2>&1)
    local ls_result=$?
    local formatted_output

    if [ $# -gt 0 ]; then
        local path_prefix=$(printf "${*%/}" | sed -e 's/[]\/$*.^|[]/\\&/g')
        formatted_output=$(printf "$ls_output" | sed -E "s/^/$path_prefix\//")
    else
        formatted_output=$ls_output
    fi

    if [[ $ls_result == 0 && "$formatted_output" ]]; then
        printf "$formatted_output\n"
        return 0
    else
        return 2
    fi
}

find_notes() {
    local find_output=$(find "$notes_dir" -ipath "$notes_dir/*$**" -type f 2>&1)
    local find_result=$?
    local formatted_output=$(printf "$find_output" | without_notes_dir)

    if [[ $find_result == 0 && "$formatted_output" ]]; then
        printf "$formatted_output\n"
        return 0
    else
        return 2
    fi
}

grep_notes() {
    if [ ! "$#" -gt 0 ]; then
        printf "Grep requires a pattern, but none was provided.\n"
        return 1
    fi

    local grep_output
    if [[ -t 1 ]]; then
        matches=$(grep --color=$GREP_COLOR -r $NOTES_DIRECTORY -in -e "$*" 2>&1)
        IFS=$'\n'
        for result in $matches; do
            len=${#result}
            grep_output+="$(echo ${result})\n"
        done
    else
        grep_output=$(grep -r "$notes_dir" -li -e "$*" 2>&1)
    fi

    local grep_result=$?
    local formatted_output=$(printf "$grep_output" | without_notes_dir)

    if [[ $grep_result == 0 && "$formatted_output" ]]; then
        printf "$formatted_output\n"
        return 0
    else
        return 2
    fi
}

new_note() {
    local note_name="$*"
    mkdir -p "$(dirname "$notes_dir/$note_name")"
    open_note "$note_name$file_ext"
}

remove_note() {
    local rm_args=()
    local files="$@"

    if [[ "$1" == "-r" || "$1" == "--recursive" ]]; then
        rm_args+=("--recursive")
        shift
    fi

    for files; do
        local note_name="$*"
        local to_remove="$notes_dir/$note_name"

        if [ -f "$notes_dir/$note_name$file_ext" ]; then
            to_remove="$notes_dir/$note_name$file_ext"
        fi
        rm "${rm_args[@]}" "$to_remove"
    done
}

open_something() {
    if [[ -p /dev/stdin ]]; then
        read -d'\n' note_names
        local buffer=()
        while read note_name; do
             buffer+=$note_name
        done <<< "$note_names"
        open_note $note_names
    elif [ $# -gt 0 ]; then
        open_note "$*"
    else
        open $notes_dir
    fi
}

open_note() {
    local note_path
    local ext_check
    local buffer=()


    for arg in $@; do

        ext_check=true
        note_path=$arg

        if echo $note_path | grep -q '\.[a-z]'; then
            ext_check=false
        fi

        if [[ "$note_path" != *$file_ext ]] && $ext_check; then
            note_path="$note_path$file_ext"
        fi
        if [ ! -f "$note_path" ]; then
            note_path="$notes_dir/$note_path"
        fi
        if [ -z "$EDITOR" ]; then
            printf "Please set \$EDITOR to edit notes\n"
            exit 1
        fi
        buffer+="$note_path "
    done

    $EDITOR $buffer < /dev/tty
}

usage() {
    cat <<EOF
notes is a command line note taking tool.

Usage:
    notes new|n <name>                    # Create a new note
    notes ls <pattern>                    # List notes by path
    notes find|f [pattern]                # Search notes by filename and path
    notes grep|g <pattern>                # Search notes by content
    notes open|o                          # Open your notes directory
    notes open|o <name>                   # Open a note for editing by full name
    notes rm [-r | --recursive] <name>    # Remove note, or folder if -r or --recursive is given
    echo <name> | notes open|o            # Open all note filenames piped in
    notes --help                          # Print this usage information

'command|c' means you can use 'command' or the equivalent shorthand alias 'c'

Your notes directory is $notes_dir. You can
override this by setting \$NOTES_DIRECTORY to your preferred path.
EOF
}

main() {
    local ret=0
    local cmd=""

    if [ -z "$1" ]; then
        printf "No command specified\n\n"
        usage
        exit 1
    fi

    case "$1" in
        "new"|"n" )
            cmd="new_note"
            ;;
        "ls" )
            cmd="ls_notes"
            ;;
        "find"|"f" )
            cmd="find_notes"
            ;;
        "grep"|"g" )
            cmd="grep_notes"
            ;;
        "open"|"o" )
            cmd="open_something"
            ;;
        "rm" )
            cmd="remove_note"
            ;;
        --help | -help | -h )
            cmd="usage"
            ;;
        * )
            printf "$1 is not a recognized notes command.\n\n"
            cmd="usage"
            ret=1
            ;;
    esac
    shift

    $cmd "$@"
    ret=$[$ret+$?]
    exit $ret
}
main "$@"
